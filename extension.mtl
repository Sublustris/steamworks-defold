// GENERATED CODE - DO NOT MODIFY
// Copyright 2016 Bjorn Ritzl

/**

{{#methods}}
{{classname_lower}}_{{methodname_lower}}({{paramnames_in}}) -> {{classname}}_{{methodname}}()
{{/methods}}

*/

#include <dmsdk/sdk.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "steam_api.h"
#include "luautils.h"

#define LIB_NAME "Steamworks"
#define MODULE_NAME "steamworks"

#ifndef DLIB_LOG_DOMAIN
#define DLIB_LOG_DOMAIN "steamworks"
#include <dmsdk/dlib/log.h>
#endif


#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_INT 0
#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_FLOAT 1
#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_AVERAGERATE 2

static ISteamClient *client;
static ISteamFriends *friends;
static ISteamUser *user;
static ISteamUserStats *userstats;
static ISteamMatchmaking *matchmaking;
static ISteamUtils *utils;


static lua_Listener steamworksListener;




static int SetListener(lua_State* L) {
	int top = lua_gettop(L);

	luaL_checklistener(L, 1, steamworksListener);

	assert(top == lua_gettop(L));
	return 0;
}





class SteamCallbackWrapper {
	public:
		SteamCallbackWrapper();

		// General
		STEAM_CALLBACK(SteamCallbackWrapper, OnGameOverlayActivated, GameOverlayActivated_t, m_CallbackGameOverlayActivated);

		// Networking
		STEAM_CALLBACK(SteamCallbackWrapper, OnLobbyChatMsg, LobbyChatMsg_t, m_CallbackLobbyChatMsg);

		// User Stats
		STEAM_CALLBACK(SteamCallbackWrapper, OnUserStatsReceived, UserStatsReceived_t, m_CallbackUserStatsReceived);
		STEAM_CALLBACK(SteamCallbackWrapper, OnUserStatsStored, UserStatsStored_t, m_CallbackUserStatsStored);
		STEAM_CALLBACK(SteamCallbackWrapper, OnAchievementStored, UserAchievementStored_t, m_CallbackAchievementStored);
		STEAM_CALLBACK(SteamCallbackWrapper, OnPS3TrophiesInstalled, PS3TrophiesInstalled_t, m_CallbackPS3TrophiesInstalled);

		void OnFindLeaderboard(LeaderboardFindResult_t *pFindLearderboardResult, bool bIOFailure);
		CCallResult<SteamCallbackWrapper, LeaderboardFindResult_t> m_SteamCallResultCreateLeaderboard;
};

SteamCallbackWrapper::SteamCallbackWrapper() :

	// General
	m_CallbackGameOverlayActivated(this, &SteamCallbackWrapper::OnGameOverlayActivated),


	// Networking
	m_CallbackLobbyChatMsg(this, &SteamCallbackWrapper::OnLobbyChatMsg),

	// User Stats
	m_CallbackUserStatsReceived(this, &SteamCallbackWrapper::OnUserStatsReceived),
	m_CallbackUserStatsStored(this, &SteamCallbackWrapper::OnUserStatsStored),
	m_CallbackAchievementStored(this, &SteamCallbackWrapper::OnAchievementStored),
	m_CallbackPS3TrophiesInstalled(this, &SteamCallbackWrapper::OnPS3TrophiesInstalled) {
}

// General
void SteamCallbackWrapper::OnGameOverlayActivated(GameOverlayActivated_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnGameOverlayActivated\n");
	// NotifyListener("OnGameOverlayActivated", pCallback);
}

// Networking
void SteamCallbackWrapper::OnLobbyChatMsg(LobbyChatMsg_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnLobbyChatMsg\n");
	// NotifyListener("OnLobbyChatMsg", pCallback);
}

// User Stats
void SteamCallbackWrapper::OnUserStatsReceived(UserStatsReceived_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnUserStatsReceived\n");
	// NotifyListener("OnUserStatsReceived");
}
void SteamCallbackWrapper::OnUserStatsStored(UserStatsStored_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnUserStatsStored\n");
	// NotifyListener("OnUserStatsStored");
}
void SteamCallbackWrapper::OnAchievementStored(UserAchievementStored_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnAchievementStored\n");
	// NotifyListener("OnAchievementStored");
}
void SteamCallbackWrapper::OnPS3TrophiesInstalled(PS3TrophiesInstalled_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnPS3TrophiesInstalled\n");
	// NotifyListener("OnPS3TrophiesInstalled");
}
void SteamCallbackWrapper::OnFindLeaderboard(LeaderboardFindResult_t *pFindLeaderboardResult, bool bIOFailure) {
	dmLogInfo("SteamCallbackWrapper::OnFindLeaderboard\n");
	// NotifyListener("OnFindLeaderboard", pFindLeaderboardResult);
}

static SteamCallbackWrapper *steamCallbackWrapper = new SteamCallbackWrapper();


/*****************************
* PUSH
******************************/

static void push_double(lua_State* L, double n) {
	lua_pushinteger(L, n);
}
static void push_int(lua_State* L, int n) {
	lua_pushinteger(L, n);
}
static void push_unsigned_int(lua_State* L, unsigned int n) {
	lua_pushinteger(L, n);
}
static void push_uint32(lua_State* L, uint32 n) {
	lua_pushinteger(L, n);
}
static void push_uint16(lua_State* L, uint16 n) {
	lua_pushinteger(L, n);
}
static void push_uint8(lua_State* L, uint8 n) {
	lua_pushinteger(L, n);
}
{{#typedefs.int}}
static void push_{{typedef}}(lua_State* L, {{typedef}} n) {
	lua_pushinteger(L, n);
}
{{/typedefs.int}}

static void push_int64(lua_State* L, int64 n) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%ld", n);
	lua_pushstring(L, buf);
}
{{#typedefs.int64}}
static void push_{{typedef}}(lua_State* L, {{typedef}} n) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%ld", n);
	lua_pushstring(L, buf);
}
{{/typedefs.int64}}

static void push_uint64(lua_State* L, uint64 n) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%llu", n);
	lua_pushstring(L, buf);
}
{{#typedefs.uint64}}
static void push_{{typedef}}(lua_State* L, {{typedef}} n) {
	push_uint64(L, n);
}
{{/typedefs.uint64}}

{{#enums}}
static void push_{{enumname}}(lua_State* L, {{enumname}} n) {
	lua_pushinteger(L, n);
}
static {{enumname}} check_{{enumname}}(lua_State* L, int index) {
	return {{enumname}}(luaL_checkinteger(L, index));
}

{{/enums}}

static void push_bool(lua_State* L, bool b) {
    lua_pushboolean(L, b);
}
static void push__Bool(lua_State* L, bool b) {
    lua_pushboolean(L, b);
}
static void push_const_char_ptr(lua_State* L, const char * s) {
    lua_pushstring(L, s);
}



static void push_CSteamID(lua_State* L, CSteamID steamId) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%llu", steamId.ConvertToUint64());
	lua_pushstring(L, buf);
}

// static void push_class_ISteamUser_ptr(lua_State* L, ISteamUser * steamuser) {
//     luaL_error(L, "push_class_ISteamUser_ptr not implemented");
// }
//
// static void push_class_ISteamFriends_ptr(lua_State* L, ISteamFriends * steamfriends) {
//     luaL_error(L, "push_class_ISteamFriends_ptr not implemented");
// }
//
// static void push_class_ISteamGameServer_ptr(lua_State* L, ISteamGameServer * gameserver) {
//     luaL_error(L, "push_class_ISteamGameServer_ptr not implemented");
// }
static void push_class_CSteamID(lua_State* L, CSteamID steamId) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%llu", steamId.ConvertToUint64());
	lua_pushstring(L, buf);
}




/*****************************
* CHECK
******************************/

static lua_Number check_int(lua_State* L, int index) {
	return luaL_checknumber(L, index);
}
static lua_Number check_uint32(lua_State* L, int index) {
	return luaL_checknumber(L, index);
}
static lua_Number check_uint16(lua_State* L, int index) {
	return luaL_checknumber(L, index);
}
static lua_Number check_bool(lua_State* L, int index) {
	return lua_toboolean(L, index);
}
// static uint32 * check_uint32_ptr(lua_State* L, int index) {
// 	uint32 i = luaL_checknumber(L, index);
// 	return &i;
// }
// static int * check_int_ptr(lua_State* L, int index) {
// 	int i = luaL_checknumber(L, index);
// 	return &i;
// }

{{#typedefs.int}}
static {{typedef}} check_{{typedef}}(lua_State* L, int index) {
	return ({{typedef}})luaL_checknumber(L, index);
}
{{/typedefs.int}}

// static HSteamPipe * check_HSteamPipe_ptr(lua_State* L, int index) {
// 	luaL_error(L, "check_HSteamPipe_ptr not implemented");
// }

static const char * check_const_char_ptr(lua_State* L, int index) {
	return luaL_checkstring(L, index);
}
static char * check_char_ptr(lua_State* L, int index) {
	return (char*)luaL_checkstring(L, index);
}
static const void * check_const_void_ptr(lua_State* L, int index) {
	return (void*)luaL_checkstring(L, index);
}
static void * check_void_ptr(lua_State* L, int index) {
	return (void*)luaL_checkstring(L, index);
}

static dmScript::LuaHBuffer * check_buffer(lua_State* L, int index) {
	return dmScript::CheckBuffer(L, index);
}



static CSteamID check_CSteamID(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	CSteamID steamId = CSteamID(id);
	return steamId;
}

static CSteamID check_class_CSteamID(lua_State* L, int index) {
	return check_CSteamID(L, index);
}

static CGameID check_class_CGameID(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	CGameID gameId = CGameID(id);
	return gameId;
}


{{#methods}}
static int {{classname}}_{{methodname}}(lua_State* L) {
	int top = lua_gettop(L);
	{{#params}}
{{#normal_param}}	{{paramtype}} {{paramname}} = check_{{paramtypestring}}(L, {{paramindex}}); /*normal*/
{{/normal_param}}{{#out_struct}}	{{paramtype}} {{paramname}}; /*out_struct*/
{{/out_struct}}{{#out_array_call}}	{{out_array_call_counter}} = {{classname_lower}}->{{out_array_call_function}}({{out_array_call_params}});/*out_array_call*/
	{{paramtype}} {{paramname}}[{{out_array_call_counter}}];
{{/out_array_call}}{{#out_array_call_param}}	{{paramtype}} {{paramname}}; /*out_array_call_param*/
{{/out_array_call_param}}{{#out_param}}	{{paramtype}} {{paramname}}; /*out_param*/
{{/out_param}}{{#array_count_param}}	{{paramtype}} {{paramname}}; /*array_count_param*/
{{/array_count_param}}{{#array_count}}	luaL_checktype(L, {{paramindex}}, LUA_TTABLE); /*array_count*/
	int n = luaL_getn(L, {{paramindex}});
	{{paramtype}} {{paramname}}[{{array_count}}];
	for(int i=1; i<={{array_count}}; i++) {
		lua_rawgeti(L, {{paramindex}}, i);
		{{paramname}}[i] = check_{{paramtype}}(L, {{paramindex}} + 1);
		lua_pop(L, 1);
	}
{{/array_count}}{{#buffer_param}}	dmScript::LuaHBuffer * {{paramname}}_buffer = check_buffer(L, {{paramindex}}); /*buffer_param*/
	void* {{paramname}} = 0x0;
	uint32_t {{paramname}}_buffersize = 0;
	dmBuffer::Result {{paramname}}_buffer_result = dmBuffer::GetBytes({{paramname}}_buffer->m_Buffer, &{{paramname}}, &{{paramname}}_buffersize);
{{/buffer_param}}
	{{/params}}

	{{#hasreturntype}}
	{{returntype}} r = {{classname_lower}}->{{methodname}}({{paramnames}});
	push_{{returntypestring}}(L, r);
	assert(top + 1 == lua_gettop(L));
	return 1;
	{{/hasreturntype}}
	{{^hasreturntype}}
	{{classname_lower}}->{{methodname}}({{paramnames}});
	assert(top + 0 == lua_gettop(L));
	return 0;
	{{/hasreturntype}}
}

{{/methods}}




static int Init(lua_State* L) {
	dmLogInfo("Init");
	SteamAPI_Init();
	if (!SteamAPI_IsSteamRunning()) {
		luaL_error(L, "Steam is not running");
	}
	client = SteamClient();
	friends = SteamFriends();
	user = SteamUser();
	utils = SteamUtils();
	matchmaking = SteamMatchmaking();
	userstats = SteamUserStats();
	userstats->RequestCurrentStats();
	return 0;
}

static int Update(lua_State* L) {
	SteamAPI_RunCallbacks();
	return 0;
}

static int Final(lua_State* L) {
	SteamAPI_Shutdown();
	return 0;
}


static const luaL_reg Module_methods[] = {
	{ "init", Init },
	{ "update", Update },
	{ "final", Final },
	{{#methods}}
	{ "{{classname_lower}}_{{methodname_lower}}", {{classname}}_{{methodname}} },
	{{/methods}}
	{ 0, 0 }
};

static void LuaInit(lua_State* L) {
	int top = lua_gettop(L);
	luaL_register(L, MODULE_NAME, Module_methods);

	#define SETCONSTANT(name, val) \
	lua_pushnumber(L, (lua_Number) val); \
	lua_setfield(L, -2, #name);

	{{#enums}}
	// {{enumname}}
	{{#values}}
	SETCONSTANT({{name}}, {{value}});
	{{/values}}
	{{/enums}}
	#undef SETCONSTANT

	lua_pop(L, 1);
	assert(top == lua_gettop(L));
}

dmExtension::Result AppInitializeSteamworks(dmExtension::AppParams* params) {
	return dmExtension::RESULT_OK;
}

dmExtension::Result InitializeSteamworks(dmExtension::Params* params) {
	LuaInit(params->m_L);
	dmLogInfo("Registered %s Extension", MODULE_NAME);
	return dmExtension::RESULT_OK;
}

dmExtension::Result AppFinalizeSteamworks(dmExtension::AppParams* params) {
	return dmExtension::RESULT_OK;
}

dmExtension::Result FinalizeSteamworks(dmExtension::Params* params) {
	return dmExtension::RESULT_OK;
}

DM_DECLARE_EXTENSION(steamworks, LIB_NAME, AppInitializeSteamworks, AppFinalizeSteamworks, InitializeSteamworks, 0, 0, FinalizeSteamworks)
