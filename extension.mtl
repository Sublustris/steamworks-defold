// GENERATED CODE - DO NOT MODIFY
// Copyright 2016 Bjorn Ritzl

/**

{{#methods}}
{{classname_lower}}_{{methodname_lower}}({{paramnames_in}}) -> {{classname}}_{{methodname}}()
{{/methods}}

*/

#include <dmsdk/sdk.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "steam_api.h"
#include "luautils.h"

#define LIB_NAME "Steamworks"
#define MODULE_NAME "steamworks"

#ifndef DLIB_LOG_DOMAIN
#define DLIB_LOG_DOMAIN "steamworks"
#include <dmsdk/dlib/log.h>
#endif


#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_INT 0
#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_FLOAT 1
#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_AVERAGERATE 2

static ISteamClient *client;
static ISteamFriends *friends;
static ISteamUser *user;
static ISteamUserStats *userstats;
static ISteamMatchmaking *matchmaking;
static ISteamUtils *utils;




/*****************************
* PUSH
******************************/

static void push_double(lua_State* L, double n) {
	lua_pushinteger(L, n);
}
static void push_int(lua_State* L, int n) {
	lua_pushinteger(L, n);
}
static void push_unsigned_int(lua_State* L, unsigned int n) {
	lua_pushinteger(L, n);
}
static void push_uint32(lua_State* L, uint32 n) {
	lua_pushinteger(L, n);
}
static void push_uint16(lua_State* L, uint16 n) {
	lua_pushinteger(L, n);
}
static void push_uint8(lua_State* L, uint8 n) {
	lua_pushinteger(L, n);
}
{{#typedefs.int}}
static void push_{{typedef}}(lua_State* L, {{typedef}} n) {
	lua_pushinteger(L, n);
}
{{/typedefs.int}}

static void push_int64(lua_State* L, int64 n) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%ld", n);
	lua_pushstring(L, buf);
}
{{#typedefs.int64}}
static void push_{{typedef}}(lua_State* L, {{typedef}} n) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%ld", n);
	lua_pushstring(L, buf);
}
{{/typedefs.int64}}

static void push_uint64(lua_State* L, uint64 n) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%llu", n);
	lua_pushstring(L, buf);
}
{{#typedefs.uint64}}
static void push_{{typedef}}(lua_State* L, {{typedef}} n) {
	push_uint64(L, n);
}
{{/typedefs.uint64}}

{{#enums}}
static void push_{{enumname}}(lua_State* L, {{enumname}} n) {
	lua_pushinteger(L, n);
}
static {{enumname}} check_{{enumname}}(lua_State* L, int index) {
	return {{enumname}}(luaL_checkinteger(L, index));
}

{{/enums}}

static void push_bool(lua_State* L, bool b) {
    lua_pushboolean(L, b);
}
static void push__Bool(lua_State* L, bool b) {
    lua_pushboolean(L, b);
}
static void push_const_char_ptr(lua_State* L, const char * s) {
    lua_pushstring(L, s);
}

static void push_CSteamID(lua_State* L, CSteamID steamId) {
	// char buf[22];
	// snprintf(buf, sizeof(buf), "%llu", steamId.ConvertToUint64());
	// lua_pushstring(L, buf);
	push_uint64(L, steamId.ConvertToUint64());
}

static void push_class_CSteamID(lua_State* L, CSteamID steamId) {
	// char buf[22];
	// snprintf(buf, sizeof(buf), "%llu", steamId.ConvertToUint64());
	// lua_pushstring(L, buf);
	push_uint64(L, steamId.ConvertToUint64());
}

static void push_CSteamID_array(lua_State* L, CSteamID steamId[], unsigned int size) {
	lua_newtable(L);
	for(int i=1; i <= size; i++) {
		lua_pushnumber(L, i);
		push_CSteamID(L, steamId[i]);
		lua_settable(L, -3);
	}
}

static void push_char_array(lua_State* L, char ca[], unsigned int size) {
	lua_pushstring(L, ca);
}

static void push_CGameID(lua_State* L, CGameID gameId) {
	push_uint64(L, gameId.ToUint64());
}


{{#structs}}
static void push_{{name}}(lua_State* L, {{name}} s) {
	lua_newtable(L);
	{{#fields}}
	lua_pushstring(L, "{{fieldname}}");
	push_{{fieldtypestring}}{{#array}}_array{{/array}}(L, s.{{fieldname}}{{#array}}, {{arraysize}}{{/array}});
	lua_settable(L, -3);
	{{/fields}}
}
{{/structs}}





/*****************************
* CHECK
******************************/

static lua_Number check_int(lua_State* L, int index) {
	return luaL_checknumber(L, index);
}
static lua_Number check_uint32(lua_State* L, int index) {
	return luaL_checknumber(L, index);
}
static lua_Number check_uint16(lua_State* L, int index) {
	return luaL_checknumber(L, index);
}
static lua_Number check_bool(lua_State* L, int index) {
	return lua_toboolean(L, index);
}

{{#typedefs.int}}
static {{typedef}} check_{{typedef}}(lua_State* L, int index) {
	return ({{typedef}})luaL_checknumber(L, index);
}
{{/typedefs.int}}

static const char * check_const_char_ptr(lua_State* L, int index) {
	return luaL_checkstring(L, index);
}
static char * check_char_ptr(lua_State* L, int index) {
	return (char*)luaL_checkstring(L, index);
}
static const void * check_const_void_ptr(lua_State* L, int index) {
	return (void*)luaL_checkstring(L, index);
}
static void * check_void_ptr(lua_State* L, int index) {
	return (void*)luaL_checkstring(L, index);
}

static dmScript::LuaHBuffer * check_buffer(lua_State* L, int index) {
	return dmScript::CheckBuffer(L, index);
}

static CSteamID check_CSteamID(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	CSteamID steamId = CSteamID(id);
	return steamId;
}

static CSteamID check_class_CSteamID(lua_State* L, int index) {
	return check_CSteamID(L, index);
}

static SteamAPICall_t check_SteamAPICall_t(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	return id;
}

static CGameID check_class_CGameID(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	CGameID gameId = CGameID(id);
	return gameId;
}




static lua_Listener steamworksListener;

class SteamCallbackWrapper {
	public:
		SteamCallbackWrapper();

		// General
		STEAM_CALLBACK(SteamCallbackWrapper, OnGameOverlayActivated, GameOverlayActivated_t, m_CallbackGameOverlayActivated);


		{{#methods}}{{#callresult}}
		CCallResult<SteamCallbackWrapper, {{callresult}}> m_CallResult{{callresult}};
		void TrackSteamAPICall{{callresult}}(SteamAPICall_t steamAPICall) {
			m_CallResult{{callresult}}.Set(steamAPICall, this, &SteamCallbackWrapper::On{{callresult}});
		}
		void On{{callresult}}({{callresult}} *pResult, bool bIOFailure) {
			dmLogInfo("SteamCallbackWrapper::On{{callresult}}\n");
			lua_State* L = steamworksListener.m_L;
			if (!L) {
				dmLogInfo("no lua state\n");
				return;
			}
			int top = lua_gettop(L);
			lua_pushlistener(L, steamworksListener);
			lua_pushstring(L, "{{callresult}}");
			push_{{callresult}}(L, *pResult);
			int ret = lua_pcall(L, 3, LUA_MULTRET, 0);
			if (ret != 0) {
				lua_pop(L, 2);
			}
			assert(top == lua_gettop(L));
		}
		{{/callresult}}{{/methods}}

		void OnFindLeaderboard(LeaderboardFindResult_t *pFindLearderboardResult, bool bIOFailure);
		CCallResult<SteamCallbackWrapper, LeaderboardFindResult_t> m_SteamCallResultCreateLeaderboard;
};

SteamCallbackWrapper::SteamCallbackWrapper() :

	// General
	m_CallbackGameOverlayActivated(this, &SteamCallbackWrapper::OnGameOverlayActivated)
{
}


// General
void SteamCallbackWrapper::OnGameOverlayActivated(GameOverlayActivated_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnGameOverlayActivated\n");
	// NotifyListener("OnGameOverlayActivated", pCallback);
}

static SteamCallbackWrapper *steamCallbackWrapper = new SteamCallbackWrapper();





{{#methods}}
static int {{classname}}_{{methodname}}(lua_State* L) {
	int top = lua_gettop(L);
	{{#params}}
{{#normal_param}}	{{paramtype}} {{paramname}} = check_{{paramtypestring}}(L, {{paramindex}}); /*normal*/
{{/normal_param}}{{#out_struct}}	{{paramtype}} {{paramname}}; /*out_struct*/
{{/out_struct}}{{#out_array_call}}	{{out_array_call_counter}} = {{classname_lower}}->{{out_array_call_function}}({{out_array_call_params}});/*out_array_call*/
	{{paramtype}} {{paramname}}[{{out_array_call_counter}}];
{{/out_array_call}}{{#out_array_call_param}}	{{paramtype}} {{paramname}}; /*out_array_call_param*/
{{/out_array_call_param}}{{#out_param}}	{{paramtype}} {{paramname}}; /*out_param*/
{{/out_param}}{{#array_count_param}}	{{paramtype}} {{paramname}}; /*array_count_param*/
{{/array_count_param}}{{#array_count}}	luaL_checktype(L, {{paramindex}}, LUA_TTABLE); /*array_count*/
	int n = luaL_getn(L, {{paramindex}});
	{{paramtype}} {{paramname}}[{{array_count}}];
	for(int i=1; i<={{array_count}}; i++) {
		lua_rawgeti(L, {{paramindex}}, i);
		{{paramname}}[i] = check_{{paramtype}}(L, {{paramindex}} + 1);
		lua_pop(L, 1);
	}
{{/array_count}}{{#buffer_param}}	dmScript::LuaHBuffer * {{paramname}}_buffer = check_buffer(L, {{paramindex}}); /*buffer_param*/
	void* {{paramname}} = 0x0;
	uint32_t {{paramname}}_buffersize = 0;
	dmBuffer::Result {{paramname}}_buffer_result = dmBuffer::GetBytes({{paramname}}_buffer->m_Buffer, &{{paramname}}, &{{paramname}}_buffersize);
{{/buffer_param}}
	{{/params}}

	{{#hasreturntype}}
	{{returntype}} r = {{classname_lower}}->{{methodname}}({{paramnames}});
	{{#steamapicall}}
	steamCallbackWrapper->TrackSteamAPICall{{callresult}}(r);
	assert(top + 0 == lua_gettop(L));
	return 0;
	{{/steamapicall}}
	{{^steamapicall}}
	push_{{returntypestring}}(L, r);
	{{#params}}{{#out_param}}push_{{paramtype}}(L, {{paramname}});
	{{/out_param}}{{/params}}
	assert(top + 1 + {{paramcount_out}} == lua_gettop(L));
	return 1 + {{paramcount_out}};
	{{/steamapicall}}
	{{/hasreturntype}}
	{{^hasreturntype}}
	{{classname_lower}}->{{methodname}}({{paramnames}});
	assert(top + 0 == lua_gettop(L));
	return 0;
	{{/hasreturntype}}
}

{{/methods}}



extern "C" void __cdecl SteamAPIDebugTextHook( int nSeverity, const char *pchDebugText )
{
	if (nSeverity == 0) {
		dmLogInfo(pchDebugText);
	}
	else {
		dmLogWarning(pchDebugText);
	}
}

static int Init(lua_State* L) {
	dmLogInfo("Init");
	SteamAPI_Init();
	if (!SteamAPI_IsSteamRunning()) {
		luaL_error(L, "Steam is not running");
	}
	client = SteamClient();
	friends = SteamFriends();
	user = SteamUser();
	utils = SteamUtils();
	utils->SetWarningMessageHook(&SteamAPIDebugTextHook);
	matchmaking = SteamMatchmaking();
	userstats = SteamUserStats();
	userstats->RequestCurrentStats();
	return 0;
}

static int Update(lua_State* L) {
	SteamAPI_RunCallbacks();
	return 0;
}

static int Final(lua_State* L) {
	SteamAPI_Shutdown();
	return 0;
}

static int SetListener(lua_State* L) {
	int top = lua_gettop(L);

	luaL_checklistener(L, 1, steamworksListener);

	assert(top == lua_gettop(L));
	return 0;
}

static const luaL_reg Module_methods[] = {
	{ "init", Init },
	{ "update", Update },
	{ "final", Final },
	{ "set_listener", SetListener },
	{{#methods}}
	{ "{{classname_lower}}_{{methodname_lower}}", {{classname}}_{{methodname}} },
	{{/methods}}
	{ 0, 0 }
};

static void LuaInit(lua_State* L) {
	int top = lua_gettop(L);
	luaL_register(L, MODULE_NAME, Module_methods);

	#define SETCONSTANT(name, val) \
	lua_pushnumber(L, (lua_Number) val); \
	lua_setfield(L, -2, #name);

	{{#enums}}
	// {{enumname}}
	{{#values}}
	SETCONSTANT({{name}}, {{value}});
	{{/values}}
	{{/enums}}
	#undef SETCONSTANT

	lua_pop(L, 1);
	assert(top == lua_gettop(L));
}

dmExtension::Result AppInitializeSteamworks(dmExtension::AppParams* params) {
	return dmExtension::RESULT_OK;
}

dmExtension::Result InitializeSteamworks(dmExtension::Params* params) {
	LuaInit(params->m_L);
	dmLogInfo("Registered %s Extension", MODULE_NAME);
	return dmExtension::RESULT_OK;
}

dmExtension::Result AppFinalizeSteamworks(dmExtension::AppParams* params) {
	return dmExtension::RESULT_OK;
}

dmExtension::Result FinalizeSteamworks(dmExtension::Params* params) {
	return dmExtension::RESULT_OK;
}

DM_DECLARE_EXTENSION(steamworks, LIB_NAME, AppInitializeSteamworks, AppFinalizeSteamworks, InitializeSteamworks, 0, 0, FinalizeSteamworks)
