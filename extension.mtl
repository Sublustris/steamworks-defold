// GENERATED CODE - DO NOT MODIFY
// Copyright 2016 Bjorn Ritzl


#include <dmsdk/sdk.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "steam_api.h"
#include "luautils.h"

#define LIB_NAME "Steamworks"
#define MODULE_NAME "steamworks"

#ifndef DLIB_LOG_DOMAIN
#define DLIB_LOG_DOMAIN "steamworks"
#include <dmsdk/dlib/log.h>
#endif




{{#typedefs}}
typedef {{typedef}} {{type}};
{{/typedefs}}


#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_INT 0
#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_FLOAT 1
#define DM_STEAMWORKS_EXTENSION_STAT_TYPE_AVERAGERATE 2

static ISteamFriends *steamFriends;
static ISteamUser *steamUser;
static ISteamUserStats *steamUserStats;
static ISteamMatchmaking *steamMatchmaking;



static lua_Listener steamworksListener;


static void NotifyListener(const char* event, LeaderboardFindResult_t *result) {

	lua_State* L = steamworksListener.m_L;
	if (!L) {
		return;
	}
	int top = lua_gettop(L);

	lua_pushlistener(L, steamworksListener);
	lua_pushstring(L, event);
	lua_newtable(L);
	lua_pushstring(L, steamUserStats->GetLeaderboardName(result->m_hSteamLeaderboard));
	lua_setfield(L, -2, "leaderboardName");
	lua_pushnumber(L, steamUserStats->GetLeaderboardEntryCount(result->m_hSteamLeaderboard));
	lua_setfield(L, -2, "entryCount");

	int ret = lua_pcall(L, 3, LUA_MULTRET, 0);
	if (ret != 0) {
		lua_pop(L, 2);
	}
	assert(top == lua_gettop(L));
}


static int SetListener(lua_State* L) {
	int top = lua_gettop(L);

	luaL_checklistener(L, 1, steamworksListener);

	assert(top == lua_gettop(L));
	return 0;
}





class SteamCallbackWrapper {
	public:
		SteamCallbackWrapper();

		// General
		STEAM_CALLBACK(SteamCallbackWrapper, OnGameOverlayActivated, GameOverlayActivated_t, m_CallbackGameOverlayActivated);

		// Networking
		STEAM_CALLBACK(SteamCallbackWrapper, OnLobbyChatMsg, LobbyChatMsg_t, m_CallbackLobbyChatMsg);

		// User Stats
		STEAM_CALLBACK(SteamCallbackWrapper, OnUserStatsReceived, UserStatsReceived_t, m_CallbackUserStatsReceived);
		STEAM_CALLBACK(SteamCallbackWrapper, OnUserStatsStored, UserStatsStored_t, m_CallbackUserStatsStored);
		STEAM_CALLBACK(SteamCallbackWrapper, OnAchievementStored, UserAchievementStored_t, m_CallbackAchievementStored);
		STEAM_CALLBACK(SteamCallbackWrapper, OnPS3TrophiesInstalled, PS3TrophiesInstalled_t, m_CallbackPS3TrophiesInstalled);

		void OnFindLeaderboard(LeaderboardFindResult_t *pFindLearderboardResult, bool bIOFailure);
		CCallResult<SteamCallbackWrapper, LeaderboardFindResult_t> m_SteamCallResultCreateLeaderboard;
};

SteamCallbackWrapper::SteamCallbackWrapper() :

	// General
	m_CallbackGameOverlayActivated(this, &SteamCallbackWrapper::OnGameOverlayActivated),


	// Networking
	m_CallbackLobbyChatMsg(this, &SteamCallbackWrapper::OnLobbyChatMsg),

	// User Stats
	m_CallbackUserStatsReceived(this, &SteamCallbackWrapper::OnUserStatsReceived),
	m_CallbackUserStatsStored(this, &SteamCallbackWrapper::OnUserStatsStored),
	m_CallbackAchievementStored(this, &SteamCallbackWrapper::OnAchievementStored),
	m_CallbackPS3TrophiesInstalled(this, &SteamCallbackWrapper::OnPS3TrophiesInstalled) {
}

// General
void SteamCallbackWrapper::OnGameOverlayActivated(GameOverlayActivated_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnGameOverlayActivated\n");
	NotifyListener("OnGameOverlayActivated", pCallback);
}

// Networking
void SteamCallbackWrapper::OnLobbyChatMsg(LobbyChatMsg_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnLobbyChatMsg\n");
	NotifyListener("OnLobbyChatMsg", pCallback);
}

// User Stats
void SteamCallbackWrapper::OnUserStatsReceived(UserStatsReceived_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnUserStatsReceived\n");
	NotifyListener("OnUserStatsReceived");
}
void SteamCallbackWrapper::OnUserStatsStored(UserStatsStored_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnUserStatsStored\n");
	NotifyListener("OnUserStatsStored");
}
void SteamCallbackWrapper::OnAchievementStored(UserAchievementStored_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnAchievementStored\n");
	NotifyListener("OnAchievementStored");
}
void SteamCallbackWrapper::OnPS3TrophiesInstalled(PS3TrophiesInstalled_t *pCallback) {
	dmLogInfo("SteamCallbackWrapper::OnPS3TrophiesInstalled\n");
	NotifyListener("OnPS3TrophiesInstalled");
}
void SteamCallbackWrapper::OnFindLeaderboard(LeaderboardFindResult_t *pFindLeaderboardResult, bool bIOFailure) {
	dmLogInfo("SteamCallbackWrapper::OnFindLeaderboard\n");
	NotifyListener("OnFindLeaderboard", pFindLeaderboardResult);
}

static SteamCallbackWrapper *steamCallbackWrapper = new SteamCallbackWrapper();









/**
 * Push a CSteamID on the stack
 * The 64 bit representation of the steam id will be
 * converted into a string
 */
static int PushSteamID(lua_State* L, CSteamID steamId) {
	char buf[22];
	snprintf(buf, sizeof(buf), "%llu", steamId.ConvertToUint64());
	lua_pushstring(L, buf);
	return 1;
}

/**
 * Get a CSteamID from the stack
 */
static CSteamID* GetSteamID(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	CSteamID *steamId = new CSteamID(id);
	return steamId;
}

static int IsLoggedInUserId(lua_State* L, int index) {
	printf("IsLoggedInUserId %d\n", index);
	if (lua_isnoneornil(L, index)) {
		return 1;
	}
	if (lua_gettop(L) == 0) {
		return 1;
	}
	if (lua_isstring(L, index)) {
		CSteamID* id = GetSteamID(L, index);
		if (steamUser->GetSteamID().ConvertToUint64() == id->ConvertToUint64()) {
			return 1;
		}
	}
	return 0;
}


static CSteamID* GetSteamID(lua_State* L, int index) {
	char * pEnd;
	const char * s = lua_tostring(L, index);
	uint64 id = strtoull(s, &pEnd, 10);
	CSteamID *steamId = new CSteamID(id);
	return steamId;
}

static void push_bool(lua_State* L, bool b) {
    lua_pushboolean(L, b);
}



{{#methods}}
static {{classname}}_{{methodname}}(lua_State* L) {
    int top = lua_gettop(L);

    {{#params}}
    {{paramtype}} {{paramname}} = check_{{paramtypestring}}(L, {{paramindex}});
    {{/params}}

    {{returntype}} r = {{classname_lower}}->{{methodname}}({{paramnames}});

    push_{{returntype}}(L, r);

    assert(top + 1 == lua_gettop(L));
    return 1;
}

{{/methods}}




static int Init(lua_State* L) {
	dmLogInfo("Init");
	SteamAPI_Init();
	if (!SteamAPI_IsSteamRunning()) {
		luaL_error(L, "Steam is not running");
	}
	steamFriends = SteamFriends();
	steamUser = SteamUser();
	steamUserStats = SteamUserStats();
	steamUserStats->RequestCurrentStats();
	return 0;
}

static int Update(lua_State* L) {
	SteamAPI_RunCallbacks();
	return 0;
}

static int Final(lua_State* L) {
	SteamAPI_Shutdown();
	return 0;
}


static const luaL_reg Module_methods[] = {
    { "init", Init },
    {{#methods}}
    { "{{classname_lower}}_{{methodname_lower}}", {{classname}}_{{methodname}} };
    {{/methods}}
    { 0, 0 }
};

static void LuaInit(lua_State* L) {
	int top = lua_gettop(L);
	luaL_register(L, MODULE_NAME, Module_methods);

	#define SETCONSTANT(name, val) \
	lua_pushnumber(L, (lua_Number) val); \
	lua_setfield(L, -2, #name);

	//SETCONSTANT(STAT_TYPE_INT, DM_STEAMWORKS_EXTENSION_STAT_TYPE_INT);

	#undef SETCONSTANT

	lua_pop(L, 1);
	assert(top == lua_gettop(L));
}

dmExtension::Result AppInitializeSteamworks(dmExtension::AppParams* params) {
	return dmExtension::RESULT_OK;
}

dmExtension::Result InitializeSteamworks(dmExtension::Params* params) {
	LuaInit(params->m_L);
	dmLogInfo("Registered %s Extension", MODULE_NAME);
	return dmExtension::RESULT_OK;
}

dmExtension::Result AppFinalizeSteamworks(dmExtension::AppParams* params) {
	return dmExtension::RESULT_OK;
}

dmExtension::Result FinalizeSteamworks(dmExtension::Params* params) {
	return dmExtension::RESULT_OK;
}

DM_DECLARE_EXTENSION(steamworks, LIB_NAME, AppInitializeSteamworks, AppFinalizeSteamworks, InitializeSteamworks, 0, 0, FinalizeSteamworks)
